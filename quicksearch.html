<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"models_channel.js.html":{"id":"models_channel.js.html","title":"Source: models/channel.js","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Source: models/channel.js import stampit from 'stampit'; import Promise from 'bluebird'; import {Meta, Model} from './base'; import Request from '../request'; import {EventEmittable} from '../utils'; const ChannelMeta = Meta({ name: 'channel', pluralName: 'channels', endpoints: { 'detail': { 'methods': ['delete', 'patch', 'put', 'get'], 'path': '/v1/instances/{instanceName}/channels/{name}/' }, 'list': { 'methods': ['post', 'get'], 'path': '/v1/instances/{instanceName}/channels/' }, 'poll': { 'methods': ['get'], 'path': '/v1/instances/{instanceName}/channels/{name}/poll/' }, 'publish': { 'methods': ['post'], 'path': '/v1/instances/{instanceName}/channels/{name}/publish/' }, 'history': { 'methods': ['get'], 'path': '/v1/instances/{instanceName}/channels/{name}/history/' } } }); const channelConstraints = { name: { presence: true, length: { minimum: 5 } }, instanceName: { presence: true, length: { minimum: 5 } } }; /** * Wrapper around {@link http://docs.syncano.io/v0.1/docs/channels-poll|channels poll} endpoint which implements `EventEmitter` interface. * Use it via `Channel` poll method. * @constructor * @type {ChannelPoll} * @property {Number} [timeout = 300000] 5 mins * @property {String} [path = null] request path * @property {Number} [lastId = null] used internally in for loop * @property {Number} [room = null] * @property {Boolean} [abort = false] used internally to conrole for loop * @example {@lang javascript} * var poll = ChannelPoll.setConfig(config)({ * path: '/v1/instances/some-instance/channels/some-channel/poll/' * }); * * poll.on('start', function() { * console.log('poll::start'); * }); * * poll.on('stop', function() { * console.log('poll::stop'); * }); * * poll.on('message', function(message) { * console.log('poll::message', message); * }); * * poll.on('create', function(data) { * console.log('poll::create', data); * }); * * poll.on('delete', function(data) { * console.log('poll::delete', data); * }); * * poll.on('update', function(data) { * console.log('poll::update', data); * }); * * poll.on('error', function(error) { * console.log('poll::error', error); * }); * * poll.start(); * */ export const ChannelPoll = stampit() .compose(Request, EventEmittable) .props({ timeout: 1000 * 60 * 5, path: null, lastId: null, room: null, abort: false }) .methods({ request() { const options = { timeout: this.timeout, query: { last_id: this.lastId, room: this.room } }; this.emit('request', options); return new Promise((resolve, reject) =&gt; { this.makeRequest('GET', this.path, options, (err, res) =&gt; { if (err || !res.ok) { return reject(err, res); } resolve(res.body, res); }); }); }, start() { this.emit('start'); // some kind of while loop which uses Promises const loop = () =&gt; { if (this.abort === true) { this.emit('stop'); return } return this.request() .then((message) =&gt; { this.emit('message', message); this.emit(message.action, message); this.lastId = message.id; return message; }) .finally(loop) .catch((error) =&gt; { if (error.timeout &amp;&amp; error.timeout === this.timeout) { return this.emit('timeout', error); } this.emit('error', error); this.stop(); }); } process.nextTick(loop); return this.stop; }, stop() { this.abort = true; return this; } }); const Channel = stampit() .compose(Model) .setMeta(ChannelMeta) .methods({ poll(options = {}, start = true) { const config = this.getConfig(); const meta = this.getMeta(); const path = meta.resolveEndpointPath('poll', this); options.path = path; const channelPoll = ChannelPoll.setConfig(config)(options); if (start === true) { channelPoll.start(); } return channelPoll; }, publish(message, room = null) { const options = { payload: { payload: JSON.stringify(message) } }; const meta = this.getMeta(); const path = meta.resolveEndpointPath('publish', this); if (room !== null) { options.payload.room = room; } return new Promise((resolve, reject) =&gt; { this.makeRequest('POST', path, options, (err, res) =&gt; { if (err || !res.ok) { return reject(err, res); } resolve(res.body, res); }); }); } }) .setConstraints(channelConstraints); export default Channel; × Search results Close "},"models_codebox.js.html":{"id":"models_codebox.js.html","title":"Source: models/codebox.js","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Source: models/codebox.js import stampit from 'stampit'; import _ from 'lodash'; import {Meta, Model} from './base'; import QuerySet from '../querySet'; const CodeBoxQuerySet = stampit().compose(QuerySet).methods({ /** * Runs CodeBox matching the given lookup properties. * @memberOf CodeBoxQuerySet * @instance * @param {Object} properties lookup properties used for path resolving * @returns {CodeBoxQuerySet} * @example {@lang javascript} * CodeBox.please().run({id: 1, instanceName: 'test-one'}).then(function(trace) {}); */ run(properties = {}, payload = {}) { this.properties = _.assign({}, this.properties, properties); this.method = 'POST'; this.endpoint = 'run'; this.payload = payload; this._serialize = false; return this; } }); const CodeBoxMeta = Meta({ name: 'codebox', pluralName: 'codeboxes', endpoints: { 'detail': { 'methods': ['delete', 'patch', 'put', 'get'], 'path': '/v1/instances/{instanceName}/codeboxes/{id}/' }, 'list': { 'methods': ['post', 'get'], 'path': '/v1/instances/{instanceName}/codeboxes/' }, 'run': { 'methods': ['post'], 'path': '/v1/instances/{instanceName}/codeboxes/{id}/run/' } }, relatedModels: [ 'CodeBoxTrace' ] }); const CodeBox = stampit() .compose(Model) .setMeta(CodeBoxMeta) .setQuerySet(CodeBoxQuerySet) .methods({ /** * Runs current CodeBox. * @memberOf CodeBox * @instance * @param {Object} [payload = {}] * @returns {Promise} * @example {@lang javascript} * CodeBox.please().get({instanceName: 'test-one', id: 1}).then(function(codebox) { codebox.run({some: 'variable'}).then(function(trace) {}); }); */ run(payload = {}) { const meta = this.getMeta(); const path = meta.resolveEndpointPath('run', this); return new Promise((resolve, reject) =&gt; { this.makeRequest('POST', path, {payload}, (err, res) =&gt; { if (err || !res.ok) { return reject(err, res); } resolve(res.body, res); }); }); } }); export default CodeBox; × Search results Close "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Source: utils.js import stampit from 'stampit'; import {EventEmitter} from 'events'; /** * Simple wrapper around `EventEmitter` * @constructor * @type {EventEmittable} * @example {@lang javascript} * var EmittableModel = stampit().compose(EventEmittable); */ export const EventEmittable = stampit.convertConstructor(EventEmitter); /** * Used as a manager for {@link Syncano} base object. **Not** meant to be used directly. * @constructor * @type {ConfigMixin} * @property {Syncano} _config private attribute which holds {@link Syncano} object * @example {@lang javascript} * var MyStamp = stampit().compose(ConfigMixin); */ export const ConfigMixin = stampit({ methods: { /** * Sets config. * @memberOf ConfigMixin * @instance * @param {Syncano} config instance of {@link Syncano} object * @returns {ConfigMixin} * @example {@lang javascript} * var MyStamp = stampit().compose(ConfigMixin); * var newObject = MyStamp().setConfig({}); */ setConfig(config) { this._config = config; return this; }, /** * Gets config. * @memberOf ConfigMixin * @instance * @returns {Syncano} * @example {@lang javascript} * var MyStamp = stampit().compose(ConfigMixin); * var config = MyStamp().getConfig(); */ getConfig() { return this._config; } }, static: { /** * Sets config and returns new {@link https://github.com/stampit-org/stampit|stampit} definition. * @memberOf ConfigMixin * @static * @param {Syncano} config instance of {@link Syncano} object * @returns {stampit} * @example {@lang javascript} * var MyStamp = stampit().compose(ConfigMixin).setConfig({}); */ setConfig(config) { return this.refs({_config: config}); }, /** * Gets config from {@link https://github.com/stampit-org/stampit|stampit} definition. * @memberOf ConfigMixin * @static * @returns {Syncano} * @example {@lang javascript} * var config = stampit().compose(ConfigMixin).getConfig(); */ getConfig() { return this.fixed.refs._config; } } }); /** * Used as a manager for {@link Meta} object. **Not** meant to be used directly. * @constructor * @type {MetaMixin} * @property {Object} _meta private attribute which holds {@link Meta} object * @example {@lang javascript} * var MyStamp = stampit().compose(MetaMixin); */ export const MetaMixin = stampit({ methods: { /** * Sets meta. * @memberOf MetaMixin * @instance * @param {Meta} meta instance of {@link Meta} object * @returns {MetaMixin} * @example {@lang javascript} * var MyStamp = stampit().compose(MetaMixin); * var newObject = MyStamp().setMeta({}); */ setMeta(meta) { this._meta = meta; return this; }, /** * Gets meta. * @memberOf MetaMixin * @instance * @returns {Meta} * @example {@lang javascript} * var MyStamp = stampit().compose(MetaMixin); * var meta = MyStamp().getMeta(); */ getMeta() { return this._meta; } }, static: { /** * Sets meta and returns new {@link https://github.com/stampit-org/stampit|stampit} definition. * @memberOf MetaMixin * @static * @param {Meta} meta instance of {@link Meta} object * @returns {stampit} * @example {@lang javascript} * var MyStamp = stampit().compose(MetaMixin).setMeta({}); */ setMeta(meta) { return this.refs({_meta: meta}); }, /** * Gets meta from {@link https://github.com/stampit-org/stampit|stampit} definition. * @memberOf MetaMixin * @static * @returns {Meta} * @example {@lang javascript} * var meta = stampit().compose(MetaMixin).getMeta(); */ getMeta() { return this.fixed.refs._meta; } } }); /** * Used as a manager for {@link http://validatejs.org/#constraints|Constraints} object (validation). **Not** meant to be used directly. * @constructor * @type {ConstraintsMixin} * @property {Object} _constraints private attribute which holds constraints object * @example {@lang javascript} * var MyStamp = stampit().compose(ConstraintsMixin); */ export const ConstraintsMixin = stampit({ methods: { /** * Sets constraints used for validation. * @memberOf ConstraintsMixin * @instance * @param {Object} constraints plain JavaScript object * @returns {ConstraintsMixin} * @example {@lang javascript} * var MyStamp = stampit().compose(ConstraintsMixin); * var newObject = MyStamp().setConstraints({}); */ setConstraints(constraints) { this._constraints = constraints; return this; }, /** * Gets constraints from object instance. * @memberOf ConstraintsMixin * @instance * @returns {Object} * @example {@lang javascript} * var MyStamp = stampit().compose(ConstraintsMixinn); * var constraints = MyStamp().getConstraints(); */ getConstraints() { return this._constraints; } }, static: { /** * Sets constraints in {@link https://github.com/stampit-org/stampit|stampit} definition used for validation. * @memberOf ConstraintsMixin * @static * @param {Object} constraints plain JavaScript object * @returns {stampit} * @example {@lang javascript} * var MyStamp = stampit().compose(ConstraintsMixin).setConstraints({}); */ setConstraints(constraints) { return this.refs({_constraints: constraints}); }, /** * Gets constraints from {@link https://github.com/stampit-org/stampit|stampit} definition. * @memberOf ConstraintsMixin * @static * @returns {Object} * @example {@lang javascript} * var constraints = stampit().compose(ConstraintsMixin).getConstraints(); */ getConstraints() { return this.fixed.refs._constraints; } } }); /** * Adds logging functionality. * @constructor * @type {Logger} * @example {@lang javascript} * var MyStamp = stampit().compose(Logger); */ export const Logger = stampit({ methods: { /** * Wrapper around *console.log*. * @memberOf Logger * @instance */ log(...args) { const env = process.env.BABEL_ENV || process.env.NODE_ENV; if (env === 'development') { /* eslint-disable no-console */ console.log(...args); /* eslint-enable no-console */ } } } }); × Search results Close "},"models_base.js.html":{"id":"models_base.js.html","title":"Source: models/base.js","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Source: models/base.js import stampit from 'stampit'; import Promise from 'bluebird'; import _ from 'lodash'; import validate from 'validate.js'; import QuerySet from '../querySet'; import Request from '../request'; import {ValidationError} from '../errors'; import {ConfigMixin, MetaMixin, ConstraintsMixin} from '../utils'; validate.Promise = Promise; /** * Object which holds whole configuration for {@link Model}. * @constructor * @type {Meta} * @property {String} [name = null] * @property {String} [pluralName = null] * @property {Array} [properties = []] * @property {Array} [endpoints = {}] * @property {Array} [relatedModels = undefined] * @example {@lang javascript} * var MyMeta = Meta({name: 'test'}); * var MyModel = SomeModel.setMeta(MyMeta); */ export const Meta = stampit() .props({ name: null, pluralName: null, properties: [], endpoints: {} }) .init(function({ instance }) { _.forEach(instance.endpoints, (value) =&gt; { value.properties = this.getPathProperties(value.path); instance.properties = _.union(instance.properties, value.properties); }); }) .methods({ /** * Gets required properties from object. Used mostly during serialization. * @memberOf Meta * @instance * @param {Object} object * @returns {Object} */ getObjectProperties(object) { return _.reduce(this.properties, (result, property) =&gt; { result[property] = object[property]; return result; }, {}); }, /** * Makes a copy of target and adds required properties from source. * @memberOf Meta * @instance * @param {Object} source * @param {Object} target * @returns {Object} */ assignProperties(source, target) { return _.assign({}, this.getObjectProperties(source), target); }, getPathProperties(path) { const re = /{([^}]*)}/gi; let match = null; let result = []; while ((match = re.exec(path)) !== null) { result.push(match[1]); } return result; }, /** * Resolves endpoint path e.g: `/v1/instances/{name}/` will be converted to `/v1/instances/someName/`. * @memberOf Meta * @instance * @param {String} endpointName * @param {Object} properties * @returns {String} */ resolveEndpointPath(endpointName, properties) { if (_.isEmpty(this.endpoints[endpointName])) { throw new Error(`Invalid endpoit name: &quot;${endpointName}&quot;.`); } const endpoint = this.endpoints[endpointName]; const diff = _.difference(endpoint.properties, _.keys(properties)); let path = endpoint.path; if (diff.length &gt; 0) { throw new Error(`Missing path properties &quot;${diff.join()}&quot; for &quot;${endpointName}&quot; endpoint.`) } _.forEach(endpoint.properties, (property) =&gt; { path = path.replace(`{${property}}`, properties[property]); }); return path; }, /** * Looks for the first allowed method from `methodNames` for selected endpoint. * @memberOf Meta * @instance * @param {String} endpointName * @param {...String} methodNames * @returns {String} */ findAllowedMethod(endpointName, ...methodNames) { const endpoint = this.endpoints[endpointName]; const methods = _.intersection(_.map(methodNames, (m) =&gt; m.toLowerCase()), endpoint.methods); if (_.isEmpty(methods)) { throw Error(`Unsupported request methods: ${methodNames.join()}.`); } return methods[0]; } }); /** * Base {@link https://github.com/stampit-org/stampit|stamp} for all models which wraps all raw JavaScript objects. * **Not** meant to be used directly more like mixin in other {@link https://github.com/stampit-org/stampit|stamps}. * @constructor * @type {Model} * @property {Syncano} _config private attribute which holds {@link Syncano} object * @property {Meta} _meta private attribute which holds {@link Meta} object * @property {Object} _constraints private attribute which holds validation constraints * @property {Request} _request private attribute which holds {@link Request} configuration * @property {Request} _querySet private attribute which holds {@link QuerySet} stamp * @example {@lang javascript} * var MyModel = stampit() .compose(Model) .setMeta(MyMeta) .setConstraints(MyConstraints); */ export const Model = stampit({ refs: { _querySet: QuerySet }, static: { /** * Sets {@link QuerySet} and returns new {@link https://github.com/stampit-org/stampit|stampit} definition. * @memberOf Model * @static * @param {QuerySet} querySet {@link QuerySet} definition * @returns {Model} * @example {@lang javascript} * var MyStamp = stampit().compose(Model).setQuerySet({}); */ setQuerySet(querySet) { return this.refs({_querySet: querySet}); }, /** * Gets {@link QuerySet} from {@link https://github.com/stampit-org/stampit|stampit} definition. * @memberOf Model * @static * @returns {QuerySet} * @example {@lang javascript} * var querySet = stampit().compose(Model).getQuerySet(); */ getQuerySet() { return this.fixed.refs._querySet; }, /** * Returns {@link QuerySet} instance which allows to do ORM like operations on {@link https://syncano.io/|Syncano} API. * @memberOf Model * @static * @param {Object} [properties = {}] some default properties for all ORM operations * @returns {QuerySet} * @example {@lang javascript} * MyModel.please().list(); */ please(properties = {}) { const querySet = this.getQuerySet(); return querySet({ model: this, properties: properties, _config: this.getConfig() }); }, /** * Used only for serialization for raw object to {@link https://github.com/stampit-org/stampit|stamp}. * @memberOf Model * @static * @param {Object} rawJSON * @param {Object} [properties = {}] some default properties which will be assigned to model instance * @returns {Model} */ fromJSON(rawJSON, properties = {}) { const meta = this.getMeta(); const attrs = meta.assignProperties(properties, rawJSON); return this(attrs); } }, methods: { /** * Checks if model instance if already saved. * @memberOf Model * @instance * @returns {Boolean} */ isNew() { return !_.has(this, 'links'); }, /** * Validates current model instance in context of defined constraints. * @memberOf Model * @instance * @returns {Object|undefined} */ validate() { const constraints = this.getConstraints(); const attributes = this.toJSON(); if (_.isEmpty(constraints)) { return; } return validate(attributes, constraints); }, /** * Serializes raw JavaScript object into {@link Model} instance. * @memberOf Model * @instance * @returns {Model} */ serialize(object) { const meta = this.getMeta(); return this.getStamp()(meta.assignProperties(this, object)); }, /** * Creates or updates the current instance. * @memberOf Model * @instance * @returns {Promise} */ save() { const meta = this.getMeta(); const errors = this.validate(); let path = null; let endpoint = 'list'; let method = 'POST'; let payload = JSON.stringify(this); return new Promise((resolve, reject) =&gt; { if (!_.isEmpty(errors)) { return reject(new ValidationError(errors)); } try { if (!this.isNew()) { endpoint = 'detail'; method = meta.findAllowedMethod(endpoint, 'PUT', 'POST'); } path = meta.resolveEndpointPath(endpoint, this); } catch(err) { return reject(err); } this.makeRequest(method, path, {payload}, (err, res) =&gt; { if (err || !res.ok) { return reject(err, res); } resolve(this.serialize(res.body), res); }); }); }, /** * Removes the current instance. * @memberOf Model * @instance * @returns {Promise} */ delete() { const meta = this.getMeta(); const path = meta.resolveEndpointPath('detail', this); return new Promise((resolve, reject) =&gt; { this.makeRequest('DELETE', path, {}, (err, res) =&gt; { if (err || !res.ok) { return reject(err, res); } resolve(null, res); }); }); }, toJSON() { return _.omit(this, '_config', '_meta', '_request', '_constraints', '_querySet'); } } }) .init(({instance, stamp}) =&gt; { if (!stamp.fixed.methods.getStamp) { stamp.fixed.methods.getStamp = () =&gt; stamp; } if(_.has(instance, '_meta.relatedModels')) { const relatedModels = instance._meta.relatedModels; const properties = instance._meta.properties.slice(); const last = _.last(properties); const lastIndex = _.lastIndexOf(properties, last); properties[lastIndex] = _.camelCase(`${instance._meta.name} ${last}`); let map = {}; map[last] = properties[lastIndex]; map = _.reduce(properties, (result, property) =&gt; { result[property] = property; return result; }, map); _.forEach(instance.getConfig(), (model, name) =&gt; { if(_.includes(relatedModels, name)) { instance[model.getMeta().pluralName] = (_properties = {}) =&gt; { const parentProperties = _.reduce(map, (result, target, source) =&gt; { const value = _.get(instance, source, null); if (value !== null) { result[target] = value; } return result; }, {}); return stampit().compose(model).please(_.assign(parentProperties, _properties)); }; } }); } }) .compose(ConfigMixin, MetaMixin, ConstraintsMixin, Request); export default Model; × Search results Close "},"querySet.js.html":{"id":"querySet.js.html","title":"Source: querySet.js","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Source: querySet.js import stampit from 'stampit'; import Promise from 'bluebird'; import _ from 'lodash'; import Request from './request'; import PaginationError from './errors'; const ResultSet = function(querySet, response, objects) { let results = []; results.push.apply(results, objects); results.next = () =&gt; { if (!response.next) { return Promise.reject(new PaginationError('There is no next page')); } return querySet.request(response.next, {query: {}}); }; results.prev = () =&gt; { if (!response.prev) { return Promise.reject(new PaginationError('There is no previous page')); } return querySet.request(response.prev, {query: {}}); }; return results; } const QuerySetRequest = stampit().compose(Request) .refs({ model: null }) .props({ endpoint: 'list', method: 'GET', headers: {}, properties: {}, query: {}, payload: {}, attachments: {}, _serialize: true }) .methods({ /** * Converts raw objects to {@link https://github.com/stampit-org/stampit|stampit} instances * @memberOf QuerySet * @instance * @private * @param {Object} response raw JavaScript objects * @returns {Object} */ serialize(response) { if (this._serialize === false) { return response; } if (this.endpoint === 'list') { const objects = _.map(response.objects, (object) =&gt; this.model.fromJSON(object, this.properties)); return ResultSet(this, response, objects); } return this.model.fromJSON(response, this.properties); }, /** * Executes current state of QuerySet * @memberOf QuerySet * @instance * @param {String} [requestPath = null] * @param {Object} [requestOptions = {}] * @returns {Promise} * @example {@lang javascript} * Instance.please().list().request().then(function(instance) {}); */ request(requestPath = null, requestOptions = {}) { const meta = this.model.getMeta(); const endpoint = meta.endpoints[this.endpoint] || {}; const allowedMethods = endpoint.methods || []; const path = requestPath || meta.resolveEndpointPath(this.endpoint, this.properties); const method = this.method.toLowerCase(); const options = _.defaults(requestOptions, { headers: this.headers, query: this.query, payload: this.payload, attachments: this.attachments }); return new Promise((resolve, reject) =&gt; { if (!_.includes(allowedMethods, method)) { return reject(new Error(`Invalid request method: &quot;${this.method}&quot;.`)); } this.makeRequest(method, path, options, (err, res) =&gt; { if (err || !res.ok) { return reject(err, res); } resolve(this.serialize(res.body), res); }); }) }, /** * Wrapper around {@link Queryset.request} method * @memberOf QuerySet * @instance * @param {function} callback * @returns {Promise} */ then(callback) { return this.request().then(callback); } }); const Create = stampit().methods({ /** * A convenience method for creating an object and saving it all in one step. * @memberOf QuerySet * @instance * @param {Object} object * @returns {Promise} * @example {@lang javascript} * // Thus: * * Instance * .please() * .create({name: 'test-one', description: 'description'}) * .then(function(instance) {}); * * // and: * * var instance = Instance({name: 'test-one', description: 'description'}); * instance.save().then(function(instance) {}); * * // are equivalent. */ create(object) { const attrs = _.assign({}, this.properties, object); const instance = this.model(attrs); return instance.save(); } }); const Get = stampit().methods({ /** * Returns the object matching the given lookup properties. * @memberOf QuerySet * @instance * @param {Object} properties lookup properties used for path resolving * @returns {QuerySet} * @example {@lang javascript} * Instance.please().get({name: 'test-one'}).then(function(instance) {}); */ get(properties = {}) { this.properties = _.assign({}, this.properties, properties); this.method = 'GET'; this.endpoint = 'detail'; return this; } }); const GetOrCreate = stampit().methods({ /** * A convenience method for looking up an object with the given lookup properties, creating one if necessary. * Successful callback will receive **object, created** arguments. * @memberOf QuerySet * @instance * @param {Object} properties attributes which will be used for object retrieving * @param {Object} defaults attributes which will be used for object creation * @returns {Promise} * @example {@lang javascript} * Instance * .please() * .getOrCreate({name: 'test-one'}, {description: 'test'}) * .then(function(instance, created) {}); * * // above is equivalent to: * * Instance * .please() * .get({name: 'test-one'}) * .then(function(instance) { * // Get * }) * .catch(function() { * // Create * return Instance.please().create({name: 'test-one', description: 'test'}); * }); */ getOrCreate(properties = {}, defaults = {}) { return new Promise((resolve, reject) =&gt; { this.get(properties) .then((object) =&gt; resolve(object, false)) .catch(() =&gt; { const attrs = _.assign({}, this.properties, properties, defaults); return this.create(attrs) .then((object) =&gt; resolve(object, true)) .catch(reject); }); }); } }); const List = stampit().methods({ /** * Returns list of objects that match the given lookup properties. * @memberOf QuerySet * @instance * @param {Object} [properties = {}] lookup properties used for path resolving * @param {Object} [query = {}] * @returns {QuerySet} * @example {@lang javascript} * Instance.please().list().then(function(instances) {}); * Class.please().list({instanceName: 'test-one'}).then(function(classes) {}); */ list(properties = {}, query = {}) { this.properties = _.assign({}, this.properties, properties); this.query = _.assign({}, this.query, query); this.method = 'GET'; this.endpoint = 'list'; return this; } }); const Delete = stampit().methods({ /** * Removes single object based on provided properties. * @memberOf QuerySet * @instance * @param {Object} properties lookup properties used for path resolving * @returns {QuerySet} * @example {@lang javascript} * Instance.please().delete({name: 'test-instance'}).then(function() {}); * Class.please().delete({name: 'test', instanceName: 'test-one'}).then(function() {}); */ delete(properties = {}) { this.properties = _.assign({}, this.properties, properties); this.method = 'DELETE'; this.endpoint = 'detail'; return this; } }); const Update = stampit().methods({ /** * Updates single object based on provided arguments * @memberOf QuerySet * @instance * @param {Object} properties lookup properties used for path resolving * @param {Object} object attributes to update * @returns {QuerySet} * @example {@lang javascript} * Instance .please() .update({name: 'test-instance'}, {description: 'new one'}) .then(function(instance) {}); * Class .please() .update({name: 'test', instanceName: 'test-one'}, {description: 'new one'}) .then(function(cls) {}); */ update(properties = {}, object = {}) { this.properties = _.assign({}, this.properties, properties); this.payload = object; this.method = 'PATCH'; this.endpoint = 'detail'; return this; } }); const UpdateOrCreate = stampit().methods({ /** * A convenience method for updating an object with the given properties, creating a new one if necessary. * Successful callback will receive **object, updated** arguments. * @memberOf QuerySet * @instance * @param {Object} properties lookup properties used for path resolving * @param {Object} [object = {}] object with (field, value) pairs used in case of update * @param {Object} [defaults = {}] object with (field, value) pairs used in case of create * @returns {Promise} * @example {@lang javascript} * Instance * .please() * .updateOrCreate({name: 'test-one'}, {description: 'new-test'}, {description: 'create-test'}) * .then(function(instance, updated) {}); * * // above is equivalent to: * * Instance * .please() * .update({name: 'test-one'}, {description: 'new-test'}) * .then(function(instance) { * // Update * }) * .catch(function() { * // Create * return Instance.please().create({name: 'test-one', description: 'create-test'}); * }); */ updateOrCreate(properties = {}, object = {}, defaults = {}) { return new Promise((resolve, reject) =&gt; { this.update(properties, object) .then((_object) =&gt; resolve(_object, true)) .catch(() =&gt; { const attrs = _.assign({}, this.properties, properties, defaults); return this.create(attrs) .then((_object) =&gt; resolve(_object, false)) .catch(reject); }) }); } }); const Fields = stampit().methods({ /** * Selects specified fields from object. * @memberOf QuerySet * @instance * @param {Object} fields * @returns {QuerySet} * @example {@lang javascript} * DataObject.please().list({ instanceName: 'test-instace', className: 'test-class' }).fields(['title', 'author']).then(function(dataobjects) {}); */ fields(fields = []) { this.query['fields'] = fields.join(); return this; } }); const First = stampit().methods({ /** * Returns the first object matched by the lookup properties or undefined, if there is no matching object. * @memberOf QuerySet * @instance * @param {Object} [properties = {}] * @param {Object} [query = {}] * @returns {Promise} * @example {@lang javascript} * Instance.please().first().then(function(instance) {}); * Class.please().first({instanceName: 'test-one'}).then(function(cls) {}); */ first(properties = {}, query = {}) { return new Promise((resolve, reject) =&gt; { this.pageSize(1) .list(properties, query) .then((objects) =&gt; { if (objects.length &gt; 0) { resolve(objects[0]); } else { resolve(); } }) .catch(reject) }); } }); const PageSize = stampit().methods({ /** * Sets page size. * @memberOf QuerySet * @instance * @param {Number} value * @returns {QuerySet} * @example {@lang javascript} * Instance.please().pageSize(2).then(function(instances) {}); * Class.please({instanceName: 'test-one'}).pageSize(2).then(function(classes) {}); */ pageSize(value) { this.query['page_size'] = value; return this; } }); const Ordering = stampit().methods({ /** * Sets order of returned objects. * @memberOf QuerySet * @instance * @param {String} [value = 'asc'] allowed choices are &quot;asc&quot; and &quot;desc&quot; * @returns {QuerySet} * @example {@lang javascript} * Instance.please().ordering('desc').then(function(instances) {}); * Class.please({instanceName: 'test-one'}).ordering('desc').then(function(classes) {}); */ ordering(value = 'asc') { const allowed = ['asc', 'desc']; const ordering = value.toLowerCase(); if (!_.includes(allowed, ordering)) { throw Error(`Invalid order value: &quot;${value}&quot;, allowed choices are ${allowed.join()}.`); } this.query['ordering'] = ordering; return this; } }); const Raw = stampit().methods({ /** * Disables serialization. Callback will will recive raw JavaScript objects. * @memberOf QuerySet * @instance * @returns {QuerySet} * @example {@lang javascript} * Instance.please().raw().then(function(response) {}); * Class.please({instanceName: 'test-one'}).raw().then(function(response) {}); */ raw() { this._serialize = false; return this; } }); /** * Base class responsible for all ORM (``please``) actions. * @constructor * @type {QuerySet} * @property {Object} model * @property {String} [endpoint = 'list'] * @property {String} [method = 'GET'] * @property {Object} [headers = {}] * @property {Object} [properties = {}] * @property {Object} [query = {}] * @property {Object} [payload = {}] * @property {Object} [attachments = {}] * @property {Boolean} [_serialize = true] */ const QuerySet = stampit.compose( QuerySetRequest, Create, Get, GetOrCreate, List, Delete, Update, UpdateOrCreate, First, PageSize, Ordering, Fields, Raw ); export default QuerySet; × Search results Close "},"models_dataobject.js.html":{"id":"models_dataobject.js.html","title":"Source: models/dataobject.js","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Source: models/dataobject.js import stampit from 'stampit'; import {Meta, Model} from './base'; import _ from 'lodash'; import QuerySet from '../querySet'; const DataObjectQuerySet = stampit().compose(QuerySet).methods({ /** * Filters DataObjects. * @memberOf QuerySet * @instance * @param {Object} filters * @returns {QuerySet} * @example {@lang javascript} * DataObject.please().list({ instanceName: 'test-instace', className: 'test-class' }).filter({ field_name: { _contains: 'Lord Of The Rings' }}).then(function(dataobjects) {}); */ filter(filters = {}) { this.query['query'] = JSON.stringify(filters); return this; }, /** * Orders DataObject by field. * @memberOf QuerySet * @instance * @param {String} field * @returns {QuerySet} * @example {@lang javascript} * DataObject.please().list({ instanceName: 'test-instace', className: 'test-class' }).orderBy('author').then(function(dataobjects) {}); * DataObject.please().list({ instanceName: 'test-instace', className: 'test-class' }).orderBy('-author').then(function(dataobjects) {}); */ orderBy(field) { this.query['order_by'] = field; return this; }, /** * Updates single object based on provided arguments * @memberOf QuerySet * @instance * @param {Object} properties lookup properties used for path resolving * @param {Object} field to increment. * @returns {QuerySet} * @example {@lang javascript} * DataObject.please().increment({instanceName: 'my-instance', className: 'my-class'', id: 1}, {views: 1}) */ increment(properties = {}, object = {}) { const payload = {}; payload[_.keys(object)[0]] = { _increment: object[_.keys(object)[0]] }; this.properties = _.assign({}, this.properties, properties); this.payload = JSON.stringify(payload); this.method = 'PATCH'; this.endpoint = 'detail'; return this; } }); const DataObjectMeta = Meta({ name: 'dataobject', pluralName: 'dataobjects', endpoints: { 'detail': { 'methods': ['delete', 'patch', 'post', 'get'], 'path': '/v1/instances/{instanceName}/classes/{className}/objects/{id}/' }, 'list': { 'methods': ['post', 'get'], 'path': '/v1/instances/{instanceName}/classes/{className}/objects/' } } }); const DataobjectConstraints = { instanceName: { presence: true, length: { minimum: 5 } }, className: { presence: true, length: { minimum: 5 } } }; const DataObject = stampit() .compose(Model) .setMeta(DataObjectMeta) .methods({ increment(field, by) { if(!_.isNumber(this[field])) throw new Error(`The ${field} is not numeric.`); if(!_.isNumber(by)) throw new Error('The provided value is not numeric.'); this[field] += _.add(this[field], by); return this.save(); } }) .setQuerySet(DataObjectQuerySet) .setConstraints(DataobjectConstraints); export default DataObject; × Search results Close "},"request.js.html":{"id":"request.js.html","title":"Source: request.js","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Source: request.js import stampit from 'stampit'; import superagent from 'superagent'; import _ from 'lodash'; import {ConfigMixin, Logger} from './utils'; import {RequestError} from './errors'; /** * Base request object **not** meant to be used directly more like mixin in other {@link https://github.com/stampit-org/stampit|stamps}. * @constructor * @type {Request} * @property {Object} _request * @property {Function} [_request.handler = superagent] * @property {Array} [_request.allowedMethods = ['GET', 'POST', 'DELETE', 'HEAD', 'PUT', 'PATCH']] * @example {@lang javascript} * var MyStamp = stampit().compose(Request); */ const Request = stampit().compose(ConfigMixin, Logger) .refs({ _request: { handler: superagent, allowedMethods: [ 'GET', 'POST', 'DELETE', 'HEAD', 'PUT', 'PATCH' ] } }) .methods({ /** * Sets request handler, used for mocking. * @memberOf Request * @instance * @param {Function} handler * @returns {Request} */ setRequestHandler(handler) { this._request.handler = handler; return this; }, /** * Gets request handler. * @memberOf Request * @instance * @returns {Function} */ getRequestHandler() { return this._request.handler; }, /** * Builds full URL based on path. * @memberOf Request * @instance * @param {String} path path part of URL e.g: /v1/instances/ * @returns {String} */ buildUrl(path) { const config = this.getConfig(); if (!_.isString(path)) { throw new Error('&quot;path&quot; needs to be a string.'); } if (_.startsWith(path, config.getBaseUrl())) { return path; } return `${config.getBaseUrl()}${path}`; }, /** * Wrapper around {@link http://visionmedia.github.io/superagent/|superagent} which validates and calls requests. * @memberOf Request * @instance * @param {String} methodName e.g GET, POST * @param {String} path e.g /v1/instances/ * @param {Object} requestOptions All options required to build request * @param {String} [requestOptions.type = 'json'] request type e.g form, json, png * @param {String} [requestOptions.accept = 'json'] request accept e.g form, json, png * @param {Number} [requestOptions.timeout = 15000] request timeout * @param {Object} [requestOptions.headers = {}] request headers * @param {Object} [requestOptions.query = {}] request query * @param {Object} [requestOptions.payload = {}] request payload * @param {Object} [requestOptions.attachments = {}] request attachments * @param {Function} callback * @returns {Request} */ makeRequest(methodName, path, requestOptions, callback) { const config = this.getConfig(); let method = (methodName || '').toUpperCase(); let options = _.defaults({}, requestOptions, { type: 'json', accept: 'json', timeout: 15000, headers: {}, query: {}, payload: {}, attachments: {} }); if (!_.isFunction(callback)) { throw new Error('&quot;callback&quot; needs to be a Function.'); } if (_.isEmpty(methodName) || !_.includes(this._request.allowedMethods, method)) { return callback(new Error(`Invalid request method: &quot;${methodName}&quot;.`)); } if (_.isEmpty(path)) { return callback(new Error('&quot;path&quot; is required.')); } if (!_.isEmpty(options.attachments)) { options.type = 'form'; } // wtf ? if (!_.isUndefined(config)) { if (!_.isEmpty(config.getAccountKey()) &amp;&amp; !_.isEmpty(config.getUserKey())) { options.headers['X-API-KEY'] = config.getAccountKey(); options.headers['X-USER-KEY'] = config.getUserKey(); } else if (_.isEmpty(options.headers['Authorization'])) { const token = config.getSocialToken() || config.getAccountKey(); if (!_.isUndefined(token) &amp;&amp; !_.isEmpty(token)) { options.headers['Authorization'] = `Token ${token}`; } } } let handler = this.getRequestHandler(); let request = handler(method, this.buildUrl(path)) .type(options.type) .accept(options.accept) .timeout(options.timeout) .set(options.headers) .query(options.query) .send(options.payload); _.forEach(options.attachments, (value, key) =&gt; { request = request.attach(key, value); }); request.end(_.wrap(callback, (_callback, err, res) =&gt; { if (!_.isUndefined(res) &amp;&amp; !res.ok) { this.log(`\\n${method} ${path}\\n${JSON.stringify(options, null, 2)}\\n`); this.log(`Response ${res.status}:`, res.body); err = new RequestError(err, res); } return _callback(err, res); })); return request; } }).static({ /** * Sets request handler and returns new {@link https://github.com/stampit-org/stampit|stampit} object, used for mocking. * @memberOf Request * @static * @returns {stampit} */ setRequestHandler(handler) { let _request = this.fixed.refs._request || {}; _request.handler = handler; return this.refs({_request}); }, /** * Sets request handler from {@link https://github.com/stampit-org/stampit|stampit} definition. * @memberOf Request * @static * @returns {Function} */ getRequestHandler() { return this.fixed.refs._request.handler; } }); export default Request; × Search results Close "},"syncano.js.html":{"id":"syncano.js.html","title":"Source: syncano.js","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Source: syncano.js import stampit from 'stampit'; import _ from 'lodash'; import models from './models'; import Account from './account'; import Pinger from './pinger'; /** * Main Syncano object. * @constructor * @type {Syncano} * @param {Object} options All configuration options * @param {Object} [options.baseUrl = 'https://api.syncano.io'] Base URL for all api calls. * @param {Object} [options.accountKey = null] Your Syncano account key. * @param {Object} [options.userKey = null] Instance user api key. * @param {Object} [options.socialToken = null] Instance social authentication token. * @returns {Syncano} * @example {@lang javascript} * var connection = Syncano({accountKey: '123'}); * var connection = Syncano({userKey: '123'}); * var connection = Syncano({socialToken: '123'}); */ const Syncano = stampit() // We need function here, do not use arrow syntax! .init(function() { this.Account = Account.setConfig(this)(); this.Monitor = Pinger.setConfig(this)(); _.forEach(models, (model, name) =&gt; { this[name] = model.setConfig(this); }); }) .refs({ baseUrl: 'https://api.syncano.io', accountKey: null, userKey: null, socialToken: null }) .methods({ /** * Sets *baseUrl*. * @memberOf Syncano * @instance * @param {String} baseUrl Base URL for all api calls * @returns {Syncano} * @throws {Error} Base URL is required. * @example {@lang javascript} * var connection = Syncano({accountKey: '123'}); * connection.setBaseUrl('https://dummy.com/'); */ setBaseUrl(baseUrl) { if(_.isEmpty(baseUrl)) throw new Error('Base URL is required.'); this.baseUrl = baseUrl; return this; }, /** * Gets *baseUrl*. * @memberOf Syncano * @instance * @returns {String} * @example {@lang javascript} * var connection = Syncano({accountKey: '123'}); * var baseUrl = connection.getBaseUrl(); */ getBaseUrl() { return this.baseUrl; }, /** * Sets *accountKey*. * @memberOf Syncano * @instance * @param {String} accountKey Your {@link https://syncano.io|Syncano} account key * @returns {Syncano} * @throws {Error} Account key is required. * @example {@lang javascript} * var connection = Syncano({accountKey: '123'}); * connection.setAccountKey('abcd'); */ setAccountKey(accountKey) { if(_.isEmpty(accountKey)) throw new Error('Account key is required.'); this.accountKey = accountKey; return this; }, /** * Gets *accountKey*. * @memberOf Syncano * @instance * @returns {String} * @example {@lang javascript} * var connection = Syncano({accountKey: '123'}); * var accountKey = connection.getAccountKey(); */ getAccountKey() { return this.accountKey; }, /** * Sets *userKey*. * @memberOf Syncano * @instance * @param {String} userKey Instance user api key * @returns {Syncano} * @throws {Error} User key is required. * @example {@lang javascript} * var connection = Syncano({userKey: '123'}); * connection.setUserKey('abcd'); */ setUserKey(userKey) { if(_.isEmpty(userKey)) throw new Error('User key is required.'); this.userKey = userKey; return this; }, /** * Gets *userKey*. * @memberOf Syncano * @instance * @returns {String} * @example {@lang javascript} * var connection = Syncano({userKey: '123'}); * var userKey = connection.getUserKey(); */ getUserKey() { return this.userKey; }, /** * Sets *socialToken*. * @memberOf Syncano * @instance * @param {String} socialToken Instance social authentication token * @returns {Syncano} * @throws {Error} Social token is required. * @example {@lang javascript} * var connection = Syncano({socialToken: '123'}); * connection.setSocialToken('abcd'); */ setSocialToken(socialToken) { if(_.isEmpty(socialToken)) throw new Error('Social token is required.'); this.socialToken = socialToken; return this; }, /** * Gets *socialToken*. * @memberOf Syncano * @instance * @returns {String} * @example {@lang javascript} * var connection = Syncano({socialToken: '123'}); * var socialToken = connection.getSocialToken(); */ getSocialToken() { return this.socialToken; } }); export default Syncano; × Search results Close "},"models_webhook.js.html":{"id":"models_webhook.js.html","title":"Source: models/webhook.js","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Source: models/webhook.js import stampit from 'stampit'; import _ from 'lodash'; import {Meta, Model} from './base'; import QuerySet from '../querySet'; const WebhookQuerySet = stampit().compose(QuerySet).methods({ /** * Runs Webhook matching the given lookup properties. * @memberOf WebhookQuerySet * @instance * @param {Object} properties lookup properties used for path resolving * @returns {Promise} * @example {@lang javascript} * Webhook.please().run({name: 'test', instanceName: 'test-one'}).then(function(trace) {}); */ run(properties = {}, payload = {}) { const WebhookTrace = this.getConfig().WebhookTrace; this.properties = _.assign({}, this.properties, properties); this.method = 'POST'; this.endpoint = 'run'; this.payload = payload; this._serialize = false; return this.then((trace) =&gt; { return WebhookTrace.fromJSON(trace, { instanceName: this.properties.instanceName, webhookName: this.properties.name }); }); }, /** * Resets Webhook matching the given lookup properties. * @memberOf WebhookQuerySet * @instance * @param {Object} properties lookup properties used for path resolving * @returns {WebhookQuerySet} * @example {@lang javascript} * Webhook.please().reset({name: 'test', instanceName: 'test-one'}).then(function(trace) {}); */ reset(properties = {}) { this.properties = _.assign({}, this.properties, properties); this.method = 'POST'; this.endpoint = 'reset'; return this; } }); const WebhookMeta = Meta({ name: 'webhook', pluralName: 'webhooks', endpoints: { 'detail': { 'methods': ['delete', 'patch', 'put', 'get'], 'path': '/v1/instances/{instanceName}/webhooks/{name}/' }, 'list': { 'methods': ['post', 'get'], 'path': '/v1/instances/{instanceName}/webhooks/' }, 'run': { 'methods': ['post'], 'path': '/v1/instances/{instanceName}/webhooks/{name}/run/' }, 'reset': { 'methods': ['post'], 'path': '/v1/instances/{instanceName}/webhooks/{name}/reset_link/' }, 'public': { 'methods': ['get'], 'path': '/v1/instances/{instanceName}/webhooks/p/{publicLink}/{name}/' } }, relatedModels: ['WebhookTrace'] }); const WebhookConstraints = { instanceName: { presence: true, length: { minimum: 5 } }, name: { presence: true, length: { minimum: 5 } }, codebox: { presence: true } }; const Webhook = stampit() .compose(Model) .setMeta(WebhookMeta) .setQuerySet(WebhookQuerySet) .setConstraints(WebhookConstraints) .methods({ /** * Runs current Webhook. * @memberOf Webhook * @instance * @param {Object} [payload = {}] * @returns {Promise} * @example {@lang javascript} * Webhook.please().get({instanceName: 'test-one', id: 1}).then(function(codebox) { codebox.run({some: 'variable'}).then(function(trace) {}); }); */ run(payload = {}) { const WebhookTrace = this.getConfig().WebhookTrace; const meta = this.getMeta(); const path = meta.resolveEndpointPath('run', this); return new Promise((resolve, reject) =&gt; { this.makeRequest('POST', path, {payload}, (err, res) =&gt; { if (err || !res.ok) { return reject(err, res); } const trace = WebhookTrace.fromJSON(res.body, { instanceName: this.instanceName, webhookName: this.name }); resolve(trace, res); }); }); }, /** * Resets current Webhook. * @memberOf Webhook * @instance * @returns {Promise} * @example {@lang javascript} * Webhook.please().get({instanceName: 'test-one', name: 'test'}).then(function(webhook) { webhook.reset().then(function() {}); }); */ reset() { const meta = this.getMeta(); const path = meta.resolveEndpointPath('reset', this); return new Promise((resolve, reject) =&gt; { this.makeRequest('POST', path, {}, (err, res) =&gt; { if (err || !res.ok) { return reject(err, res); } resolve(this.serialize(res.body), res); }); }); } }); export default Webhook; × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Classes Classes ChannelPoll ConfigMixin ConstraintsMixin EventEmittable Logger Meta MetaMixin Model QuerySet Request Syncano × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Tutorials Classes ChannelPoll ConfigMixin ConstraintsMixin EventEmittable Logger Meta MetaMixin Model QuerySet Request Syncano × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Syncano Javascript Library This library enables you to interact with the Syncano platform via Javascript. For more information on the platform, please refer to the docs and the FAQ. Also check out our libraries for iOS, Python, Ruby, Android and Arduino. We also have an AngularJs integration available. Getting startedIn order to use the plaftorm, you need an account - you can sign up here. The library can be used server-side and client-side. You can install the library using npm, bower or by downloading a release from the Github repository. We also have out own CDN. Installing from Bowerbower install syncano --saveClient-side usage&lt;script src=&quot;path/to/bower_components/syncano/dist/syncano.min.js&quot;&gt;&lt;/script&gt;Installing from NPMnpm install syncano --saveServer-side usageThe library supports the CommonJS syntax: var Syncano = require('syncano');You can also use it with ES6 modules: import Syncano from 'syncano';Creating a connectionTo create a connection, simply initialize the Syncano object with the following configuration parameters: // create a connection with an account key var connection = Syncano({ accountKey: 'MY_ACCOUNT_KEY'}); // create a connection with a user key var connection = Syncano({ userKey: 'USER_KEY'}); // create a connection with a social token var connection = Syncano({ userKey: 'SOCIAL_TOKEN'});From now on, you can access all of the objects on the platform via the connection object. Basic interactionsModel instancesThe connection you configured in the previous step has a set of factories that make interacting with objects on the platform easier. For example, if you would like to create a new instance object, you can do it like so: var instance = connection.Instance({ name: 'INSTANCE_NAME', description: 'INSTANCE_DESCRIPTION' });You can later save the instance, by calling its save method: instance.save();Nested modelsThe objects (models) are also nested, so if you would like to list the Classes of an Instance, there's an elegant function chain for that: connection.Instance({name: 'silent-dawn-3609'}).classes().list()QuerySetEvery model has a static please method that returns a QuerySet object allowing you to perform additional queries like like listing objects: connection.Instance.please().list();PromisesThe library uses Promises to enforce writing more readable and elegant code. You can get the result of a query with the then metod and the errors with the catch method: connection.Instance.please().list() .then(function(result) { // handle result }) .catch(function(error) { // handle error });ContributingThis library is built using Stampit. If you find a bug, feel free to submit an issue. If you would like to directly contribute to the library, we are open for pull requests. Contributors Daniel Kopka - twitter, github Jakub Bilko - twitter, github Changelog × Search results Close "},"ChannelPoll.html":{"id":"ChannelPoll.html","title":"Class: ChannelPoll","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Class: ChannelPoll ChannelPoll new ChannelPoll() Wrapper around channels poll endpoint which implements EventEmitter interface.Use it via Channel poll method. Properties: Name Type Argument Default Description timeout Number &lt;optional&gt; 300000 5 mins path String &lt;optional&gt; null request path lastId Number &lt;optional&gt; null used internally in for loop room Number &lt;optional&gt; null abort Boolean &lt;optional&gt; false used internally to conrole for loop Source: models/channel.js, line 99 Example var poll = ChannelPoll.setConfig(config)({ path: '/v1/instances/some-instance/channels/some-channel/poll/' }); poll.on('start', function() { console.log('poll::start'); }); poll.on('stop', function() { console.log('poll::stop'); }); poll.on('message', function(message) { console.log('poll::message', message); }); poll.on('create', function(data) { console.log('poll::create', data); }); poll.on('delete', function(data) { console.log('poll::delete', data); }); poll.on('update', function(data) { console.log('poll::update', data); }); poll.on('error', function(error) { console.log('poll::error', error); }); poll.start(); × Search results Close "},"ConfigMixin.html":{"id":"ConfigMixin.html","title":"Class: ConfigMixin","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Class: ConfigMixin ConfigMixin new ConfigMixin() Used as a manager for Syncano base object. Not meant to be used directly. Properties: Name Type Description _config Syncano private attribute which holds Syncano object Source: utils.js, line 25 Example var MyStamp = stampit().compose(ConfigMixin); Methods &lt;static&gt; getConfig() Gets config from stampit definition. Source: utils.js, line 94 Returns: Type Syncano Example var config = stampit().compose(ConfigMixin).getConfig(); &lt;static&gt; setConfig(config) Sets config and returns new stampit definition. Parameters: Name Type Description config Syncano instance of Syncano object Source: utils.js, line 79 Returns: Type stampit Example var MyStamp = stampit().compose(ConfigMixin).setConfig({}); getConfig() Gets config. Source: utils.js, line 59 Returns: Type Syncano Example var MyStamp = stampit().compose(ConfigMixin); var config = MyStamp().getConfig(); setConfig(config) Sets config. Parameters: Name Type Description config Syncano instance of Syncano object Source: utils.js, line 42 Returns: Type ConfigMixin Example var MyStamp = stampit().compose(ConfigMixin); var newObject = MyStamp().setConfig({}); × Search results Close "},"ConstraintsMixin.html":{"id":"ConstraintsMixin.html","title":"Class: ConstraintsMixin","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Class: ConstraintsMixin ConstraintsMixin new ConstraintsMixin() Used as a manager for Constraints object (validation). Not meant to be used directly. Properties: Name Type Description _constraints Object private attribute which holds constraints object Source: utils.js, line 195 Example var MyStamp = stampit().compose(ConstraintsMixin); Methods &lt;static&gt; getConstraints() Gets constraints from stampit definition. Source: utils.js, line 264 Returns: Type Object Example var constraints = stampit().compose(ConstraintsMixin).getConstraints(); &lt;static&gt; setConstraints(constraints) Sets constraints in stampit definition used for validation. Parameters: Name Type Description constraints Object plain JavaScript object Source: utils.js, line 249 Returns: Type stampit Example var MyStamp = stampit().compose(ConstraintsMixin).setConstraints({}); getConstraints() Gets constraints from object instance. Source: utils.js, line 229 Returns: Type Object Example var MyStamp = stampit().compose(ConstraintsMixinn); var constraints = MyStamp().getConstraints(); setConstraints(constraints) Sets constraints used for validation. Parameters: Name Type Description constraints Object plain JavaScript object Source: utils.js, line 212 Returns: Type ConstraintsMixin Example var MyStamp = stampit().compose(ConstraintsMixin); var newObject = MyStamp().setConstraints({}); × Search results Close "},"EventEmittable.html":{"id":"EventEmittable.html","title":"Class: EventEmittable","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Class: EventEmittable EventEmittable new EventEmittable() Simple wrapper around EventEmitter Source: utils.js, line 12 Example var EmittableModel = stampit().compose(EventEmittable); × Search results Close "},"Logger.html":{"id":"Logger.html","title":"Class: Logger","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Class: Logger Logger new Logger() Adds logging functionality. Source: utils.js, line 278 Example var MyStamp = stampit().compose(Logger); Methods log() Wrapper around console.log. Source: utils.js, line 286 × Search results Close "},"Meta.html":{"id":"Meta.html","title":"Class: Meta","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Class: Meta Meta new Meta() Object which holds whole configuration for Model. Properties: Name Type Argument Default Description name String &lt;optional&gt; null pluralName String &lt;optional&gt; null properties Array &lt;optional&gt; [] endpoints Array &lt;optional&gt; {} relatedModels Array &lt;optional&gt; Source: models/base.js, line 29 Example var MyMeta = Meta({name: 'test'}); var MyModel = SomeModel.setMeta(MyMeta); Methods assignProperties(source, target) Makes a copy of target and adds required properties from source. Parameters: Name Type Description source Object target Object Source: models/base.js, line 69 Returns: Type Object findAllowedMethod(endpointName, methodNames) Looks for the first allowed method from methodNames for selected endpoint. Parameters: Name Type Argument Description endpointName String methodNames String &lt;repeatable&gt; Source: models/base.js, line 127 Returns: Type String getObjectProperties(object) Gets required properties from object. Used mostly during serialization. Parameters: Name Type Description object Object Source: models/base.js, line 51 Returns: Type Object resolveEndpointPath(endpointName, properties) Resolves endpoint path e.g: /v1/instances/{name}/ will be converted to /v1/instances/someName/. Parameters: Name Type Description endpointName String properties Object Source: models/base.js, line 96 Returns: Type String × Search results Close "},"MetaMixin.html":{"id":"MetaMixin.html","title":"Class: MetaMixin","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Class: MetaMixin MetaMixin new MetaMixin() Used as a manager for Meta object. Not meant to be used directly. Properties: Name Type Description _meta Object private attribute which holds Meta object Source: utils.js, line 110 Example var MyStamp = stampit().compose(MetaMixin); Methods &lt;static&gt; getMeta() Gets meta from stampit definition. Source: utils.js, line 179 Returns: Type Meta Example var meta = stampit().compose(MetaMixin).getMeta(); &lt;static&gt; setMeta(meta) Sets meta and returns new stampit definition. Parameters: Name Type Description meta Meta instance of Meta object Source: utils.js, line 164 Returns: Type stampit Example var MyStamp = stampit().compose(MetaMixin).setMeta({}); getMeta() Gets meta. Source: utils.js, line 144 Returns: Type Meta Example var MyStamp = stampit().compose(MetaMixin); var meta = MyStamp().getMeta(); setMeta(meta) Sets meta. Parameters: Name Type Description meta Meta instance of Meta object Source: utils.js, line 127 Returns: Type MetaMixin Example var MyStamp = stampit().compose(MetaMixin); var newObject = MyStamp().setMeta({}); × Search results Close "},"Model.html":{"id":"Model.html","title":"Class: Model","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Class: Model Model new Model() Base stamp for all models which wraps all raw JavaScript objects.Not meant to be used directly more like mixin in other stamps. Properties: Name Type Description _config Syncano private attribute which holds Syncano object _meta Meta private attribute which holds Meta object _constraints Object private attribute which holds validation constraints _request Request private attribute which holds Request configuration _querySet Request private attribute which holds QuerySet stamp Source: models/base.js, line 158 Example var MyModel = stampit() .compose(Model) .setMeta(MyMeta) .setConstraints(MyConstraints); Methods &lt;static&gt; fromJSON(rawJSON, properties) Used only for serialization for raw object to stamp. Parameters: Name Type Argument Default Description rawJSON Object properties Object &lt;optional&gt; {} some default properties which will be assigned to model instance Source: models/base.js, line 229 Returns: Type Model &lt;static&gt; getQuerySet() Gets QuerySet from stampit definition. Source: models/base.js, line 192 Returns: Type QuerySet Example var querySet = stampit().compose(Model).getQuerySet(); &lt;static&gt; please(properties) Returns QuerySet instance which allows to do ORM like operations on Syncano API. Parameters: Name Type Argument Default Description properties Object &lt;optional&gt; {} some default properties for all ORM operations Source: models/base.js, line 209 Returns: Type QuerySet Example MyModel.please().list(); &lt;static&gt; setQuerySet(querySet) Sets QuerySet and returns new stampit definition. Parameters: Name Type Description querySet QuerySet QuerySet definition Source: models/base.js, line 177 Returns: Type Model Example var MyStamp = stampit().compose(Model).setQuerySet({}); delete() Removes the current instance. Source: models/base.js, line 320 Returns: Type Promise isNew() Checks if model instance if already saved. Source: models/base.js, line 243 Returns: Type Boolean save() Creates or updates the current instance. Source: models/base.js, line 281 Returns: Type Promise serialize() Serializes raw JavaScript object into Model instance. Source: models/base.js, line 270 Returns: Type Model validate() Validates current model instance in context of defined constraints. Source: models/base.js, line 253 Returns: Type Object | undefined × Search results Close "},"QuerySet.html":{"id":"QuerySet.html","title":"Class: QuerySet","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Class: QuerySet QuerySet new QuerySet() Base class responsible for all ORM (please) actions. Properties: Name Type Argument Default Description model Object endpoint String &lt;optional&gt; 'list' method String &lt;optional&gt; 'GET' headers Object &lt;optional&gt; {} properties Object &lt;optional&gt; {} query Object &lt;optional&gt; {} payload Object &lt;optional&gt; {} attachments Object &lt;optional&gt; {} _serialize Boolean &lt;optional&gt; true Source: querySet.js, line 507 Methods create(object) A convenience method for creating an object and saving it all in one step. Parameters: Name Type Description object Object Source: querySet.js, line 154 Returns: Type Promise Example // Thus: Instance .please() .create({name: 'test-one', description: 'description'}) .then(function(instance) {}); // and: var instance = Instance({name: 'test-one', description: 'description'}); instance.save().then(function(instance) {}); // are equivalent. delete(properties) Removes single object based on provided properties. Parameters: Name Type Description properties Object lookup properties used for path resolving Source: querySet.js, line 276 Returns: Type QuerySet Example Instance.please().delete({name: 'test-instance'}).then(function() {}); Class.please().delete({name: 'test', instanceName: 'test-one'}).then(function() {}); fields(fields) Selects specified fields from object. Parameters: Name Type Description fields Object Source: querySet.js, line 381 Returns: Type QuerySet Example DataObject.please().list({ instanceName: 'test-instace', className: 'test-class' }).fields(['title', 'author']).then(function(dataobjects) {}); filter(filters) Filters DataObjects. Parameters: Name Type Description filters Object Source: models/dataobject.js, line 20 Returns: Type QuerySet Example DataObject.please().list({ instanceName: 'test-instace', className: 'test-class' }).filter({ field_name: { _contains: 'Lord Of The Rings' }}).then(function(dataobjects) {}); first(properties, query) Returns the first object matched by the lookup properties or undefined, if there is no matching object. Parameters: Name Type Argument Default Description properties Object &lt;optional&gt; {} query Object &lt;optional&gt; {} Source: querySet.js, line 404 Returns: Type Promise Example Instance.please().first().then(function(instance) {}); Class.please().first({instanceName: 'test-one'}).then(function(cls) {}); get(properties) Returns the object matching the given lookup properties. Parameters: Name Type Description properties Object lookup properties used for path resolving Source: querySet.js, line 176 Returns: Type QuerySet Example Instance.please().get({name: 'test-one'}).then(function(instance) {}); getOrCreate(properties, defaults) A convenience method for looking up an object with the given lookup properties, creating one if necessary.Successful callback will receive object, created arguments. Parameters: Name Type Description properties Object attributes which will be used for object retrieving defaults Object attributes which will be used for object creation Source: querySet.js, line 219 Returns: Type Promise Example Instance .please() .getOrCreate({name: 'test-one'}, {description: 'test'}) .then(function(instance, created) {}); // above is equivalent to: Instance .please() .get({name: 'test-one'}) .then(function(instance) { // Get }) .catch(function() { // Create return Instance.please().create({name: 'test-one', description: 'test'}); }); increment(properties, field) Updates single object based on provided arguments Parameters: Name Type Description properties Object lookup properties used for path resolving field Object to increment. Source: models/dataobject.js, line 56 Returns: Type QuerySet Example DataObject.please().increment({instanceName: 'my-instance', className: 'my-class'', id: 1}, {views: 1}) list(properties, query) Returns list of objects that match the given lookup properties. Parameters: Name Type Argument Default Description properties Object &lt;optional&gt; {} lookup properties used for path resolving query Object &lt;optional&gt; {} Source: querySet.js, line 250 Returns: Type QuerySet Example Instance.please().list().then(function(instances) {}); Class.please().list({instanceName: 'test-one'}).then(function(classes) {}); orderBy(field) Orders DataObject by field. Parameters: Name Type Description field String Source: models/dataobject.js, line 38 Returns: Type QuerySet Example DataObject.please().list({ instanceName: 'test-instace', className: 'test-class' }).orderBy('author').then(function(dataobjects) {}); DataObject.please().list({ instanceName: 'test-instace', className: 'test-class' }).orderBy('-author').then(function(dataobjects) {}); ordering(value) Sets order of returned objects. Parameters: Name Type Argument Default Description value String &lt;optional&gt; 'asc' allowed choices are &quot;asc&quot; and &quot;desc&quot; Source: querySet.js, line 458 Returns: Type QuerySet Example Instance.please().ordering('desc').then(function(instances) {}); Class.please({instanceName: 'test-one'}).ordering('desc').then(function(classes) {}); pageSize(value) Sets page size. Parameters: Name Type Description value Number Source: querySet.js, line 436 Returns: Type QuerySet Example Instance.please().pageSize(2).then(function(instances) {}); Class.please({instanceName: 'test-one'}).pageSize(2).then(function(classes) {}); raw() Disables serialization. Callback will will recive raw JavaScript objects. Source: querySet.js, line 486 Returns: Type QuerySet Example Instance.please().raw().then(function(response) {}); Class.please({instanceName: 'test-one'}).raw().then(function(response) {}); request(requestPath, requestOptions) Executes current state of QuerySet Parameters: Name Type Argument Default Description requestPath String &lt;optional&gt; null requestOptions Object &lt;optional&gt; {} Source: querySet.js, line 85 Returns: Type Promise Example Instance.please().list().request().then(function(instance) {}); then(callback) Wrapper around Queryset.request method Parameters: Name Type Description callback function Source: querySet.js, line 121 Returns: Type Promise update(properties, object) Updates single object based on provided arguments Parameters: Name Type Description properties Object lookup properties used for path resolving object Object attributes to update Source: querySet.js, line 309 Returns: Type QuerySet Example Instance .please() .update({name: 'test-instance'}, {description: 'new one'}) .then(function(instance) {}); Class .please() .update({name: 'test', instanceName: 'test-one'}, {description: 'new one'}) .then(function(cls) {}); updateOrCreate(properties, object, defaults) A convenience method for updating an object with the given properties, creating a new one if necessary.Successful callback will receive object, updated arguments. Parameters: Name Type Argument Default Description properties Object lookup properties used for path resolving object Object &lt;optional&gt; {} object with (field, value) pairs used in case of update defaults Object &lt;optional&gt; {} object with (field, value) pairs used in case of create Source: querySet.js, line 353 Returns: Type Promise Example Instance .please() .updateOrCreate({name: 'test-one'}, {description: 'new-test'}, {description: 'create-test'}) .then(function(instance, updated) {}); // above is equivalent to: Instance .please() .update({name: 'test-one'}, {description: 'new-test'}) .then(function(instance) { // Update }) .catch(function() { // Create return Instance.please().create({name: 'test-one', description: 'create-test'}); }); × Search results Close "},"Request.html":{"id":"Request.html","title":"Class: Request","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Class: Request Request new Request() Base request object not meant to be used directly more like mixin in other stamps. Properties: Name Type Description _request Object Properties Name Type Argument Default Description handler function &lt;optional&gt; superagent allowedMethods Array &lt;optional&gt; ['GET', 'POST', 'DELETE', 'HEAD', 'PUT', 'PATCH'] Source: request.js, line 20 Example var MyStamp = stampit().compose(Request); Methods &lt;static&gt; getRequestHandler() Sets request handler from stampit definition. Source: request.js, line 191 Returns: Type function &lt;static&gt; setRequestHandler() Sets request handler and returns new stampit object, used for mocking. Source: request.js, line 179 Returns: Type stampit buildUrl(path) Builds full URL based on path. Parameters: Name Type Description path String path part of URL e.g: /v1/instances/ Source: request.js, line 68 Returns: Type String getRequestHandler() Gets request handler. Source: request.js, line 54 Returns: Type function makeRequest(methodName, path, requestOptions, callback) Wrapper around superagent which validates and calls requests. Parameters: Name Type Description methodName String e.g GET, POST path String e.g /v1/instances/ requestOptions Object All options required to build request Properties Name Type Argument Default Description type String &lt;optional&gt; 'json' request type e.g form, json, png accept String &lt;optional&gt; 'json' request accept e.g form, json, png timeout Number &lt;optional&gt; 15000 request timeout headers Object &lt;optional&gt; {} request headers query Object &lt;optional&gt; {} request query payload Object &lt;optional&gt; {} request payload attachments Object &lt;optional&gt; {} request attachments callback function Source: request.js, line 102 Returns: Type Request setRequestHandler(handler) Sets request handler, used for mocking. Parameters: Name Type Description handler function Source: request.js, line 43 Returns: Type Request × Search results Close "},"Syncano.html":{"id":"Syncano.html","title":"Class: Syncano","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Class: Syncano Syncano new Syncano(options) Main Syncano object. Parameters: Name Type Description options Object All configuration options Properties Name Type Argument Default Description baseUrl Object &lt;optional&gt; 'https://api.syncano.io' Base URL for all api calls. accountKey Object &lt;optional&gt; null Your Syncano account key. userKey Object &lt;optional&gt; null Instance user api key. socialToken Object &lt;optional&gt; null Instance social authentication token. Source: syncano.js, line 24 Returns: Type Syncano Example var connection = Syncano({accountKey: '123'}); var connection = Syncano({userKey: '123'}); var connection = Syncano({socialToken: '123'}); Methods getAccountKey() Gets accountKey. Source: syncano.js, line 112 Returns: Type String Example var connection = Syncano({accountKey: '123'}); var accountKey = connection.getAccountKey(); getBaseUrl() Gets baseUrl. Source: syncano.js, line 75 Returns: Type String Example var connection = Syncano({accountKey: '123'}); var baseUrl = connection.getBaseUrl(); getSocialToken() Gets socialToken. Source: syncano.js, line 186 Returns: Type String Example var connection = Syncano({socialToken: '123'}); var socialToken = connection.getSocialToken(); getUserKey() Gets userKey. Source: syncano.js, line 149 Returns: Type String Example var connection = Syncano({userKey: '123'}); var userKey = connection.getUserKey(); setAccountKey(accountKey) Sets accountKey. Parameters: Name Type Description accountKey String Your Syncano account key Source: syncano.js, line 94 Throws: Account key is required. Type Error Returns: Type Syncano Example var connection = Syncano({accountKey: '123'}); connection.setAccountKey('abcd'); setBaseUrl(baseUrl) Sets baseUrl. Parameters: Name Type Description baseUrl String Base URL for all api calls Source: syncano.js, line 57 Throws: Base URL is required. Type Error Returns: Type Syncano Example var connection = Syncano({accountKey: '123'}); connection.setBaseUrl('https://dummy.com/'); setSocialToken(socialToken) Sets socialToken. Parameters: Name Type Description socialToken String Instance social authentication token Source: syncano.js, line 168 Throws: Social token is required. Type Error Returns: Type Syncano Example var connection = Syncano({socialToken: '123'}); connection.setSocialToken('abcd'); setUserKey(userKey) Sets userKey. Parameters: Name Type Description userKey String Instance user api key Source: syncano.js, line 131 Throws: User key is required. Type Error Returns: Type Syncano Example var connection = Syncano({userKey: '123'}); connection.setUserKey('abcd'); × Search results Close "},"tutorial-Interacting.html":{"id":"tutorial-Interacting.html","title":"Tutorial: Interacting","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Interacting This tutorial will walk you through our ORM syntax and how to use it to make proper API calls. Creating a ConnectionIn each example I'll be assuming that you have configured connection to syncano and you are using ES6 syntax: import Syncano from 'syncano'; const connection = Syncano({accountKey: 'YOUR_KEY'})Creating objectsA model class represents a single Syncano API endpoint, and an instance of that class represents a particular record in this endpoint. To create an object, instantiate it using object argument and then call Model.save to save it to the Syncano API. Here’s an example: connection.Instance({name: 'test-one', description:''}).save().then((instance) =&gt; { // your new instance });This performs a POST request to Syncano API behind the scenes.Syncano doesn’t hit the API until you explicitly call Model#save. NoteTo create and save an object in a single step, use the QuerySet#create method. Saving changes to objectsTo save changes to an object that’s already in the Syncano API, use Model#save.Regarding our instance from previous example, this example changes its description and updates its record in the Syncano API: instance.description = 'new description' instance.save().then((updatedInstance) =&gt; { console.log(updatedInstance.description); // will produce 'new description' });This performs a PUT request to Syncano API behind the scenes.Syncano doesn’t hit the API until you explicitly call Model#save. NoteTo change and save an object in a single step, use the QuerySet#create method. Retrieving objectsTo retrieve objects from Syncano API, construct a query via a QuerySet on your model class. Each model has only one QuerySet#create, and it’s called please by default.Access it directly via the model class, like so: connection.Instance.please()NoteQuerySet is accessible only via model classes, rather than from model instances,to enforce a separation between “table-level” operations and “record-level” operations. Retrieving all objectsThe simplest way to retrieve objects from a Syncano API is to get all of them.To do this, use the QuerySet#list method on a QuerySet: connection.Instance.please().list().then((instances) =&gt; { console.log('instances', instances); });NoteThis performs a GET request to Syncano API list endpoint behind the scenes. × Search results Close "},"tutorial-Quickstart.html":{"id":"tutorial-Quickstart.html","title":"Tutorial: Quickstart","body":" Syncano Classes ChannelPollConfigMixinConstraintsMixinEventEmittableLoggerMetaMetaMixinModelQuerySetRequestSyncano Tutorials InteractingQuickstart Quickstart This quickstart guide will walk you through the installation steps of the Syncano javascript library. If you don't have a Syncano account yet, you can read about how to create one here. InstallationWe offer a few ways of installing the library - npm, bower, a GitHub repository or through our CDN. NPMInstall the npm module using: npm install syncano --save BowerInstall the bower module using: bower install syncano GithubDownload the latest release here or browse the library. CDNThe library is available on our official CDN: http://cdn.syncano.com/syncano.js Including the library in your projectScript tagTo use the library on the client side, include it via a script tag in your HTML document: &lt;script src=&quot;path/to/bower_components/syncano/dist/syncano.min.js&quot;&gt;&lt;/script&gt; CommonJSThe library can be used as CommonJS module via require: var Syncano = require('syncano'); ES6 modulesYou can also use the library via import: import Syncano from 'syncano'; Making connectionsConnecting to our services is as easy as instantiating the main object. import Syncano from 'syncano'; var connection = Syncano();You can configure your connection by passing a configuration object to the main Syncano object: var connection = Syncano({ accountKey: '123' });The main object also provides setters for the parameters: var connection = Syncano().setAccountKey('123');For a full list of the main object's properties, please refer to it's documentation. Interacting with the APIThe library provides a set of models that reflect the objects available in our API. To see a list of available objects, head on to the FAQ. There are two ways of accessing the models: by instatiating the model or by calling the static please() method that returns a QuerySet. With a model instance, you can save, update and delete objects: connection.Instance({ name: 'myInstance', description: 'This is my instance'}).save();With a QuerySet object returned from the please() method, you can perform additional operations like listing objects: connection.Instance.please().list();Queries and PromisesThe library uses Promises for hadling the results of operations on the API. They help you write more readable and maintainable code while interacting with our services. To get the result of a successful query, use the then() method: connection.Instance.please().get({ name: 'myInstance' }).then(function(result) { // manipulate the result });To catch errors returned from the API, use the catch() method: connection.Instance({ name: 'myInstance', description: 'This is my instance'}).save().catch(function(error) { // handle the error })This pattern also provides you with an elegant way of chaining operations: // create an instance connection.Instance({ name: 'myInstance', description: 'This is my instance'}).save().then(function(instance) { // update the instance's description instance.description = 'This is a new description.'; return instance.save(); }) .then(function(instance) { // the instance was updated });For a list of available query methods, check the QuerySet documentation. Nested modelsThe javascript library is designed so that it reflects the platfom's structure, therefore some of the models have child models. For example, an Instance has mutliple Classes. If we would like to list the Classes belonging to an Instance we can do something like this: connection.Instance({name: 'silent-dawn-3609'}).classes().list().then(function(classes) { // classes list }); × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
